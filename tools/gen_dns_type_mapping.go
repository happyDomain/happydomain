// This file is part of the happyDomain (R) project.
// Copyright (c) 2020-2025 happyDomain
// Authors: Pierre-Olivier Mercier, et al.
//
// This program is offered under a commercial and under the AGPL license.
// For commercial licensing, contact us at <contact@happydomain.org>.
//
// For AGPL licensing:
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

//go:build ignore
// +build ignore

package main

import (
	"flag"
	"fmt"
	"os"
	"sort"
	"strings"
	"text/template"
	"time"

	"github.com/miekg/dns"
)

type DNSType struct {
	Name     string
	Constant string
}

// getSortedTypes returns DNS types sorted by their numeric value for reproducible output
func getSortedTypes() []uint16 {
	types := make([]uint16, 0, len(dns.TypeToString))
	for ty := range dns.TypeToString {
		types = append(types, ty)
	}
	sort.Slice(types, func(i, j int) bool {
		return types[i] < types[j]
	})
	return types
}

func main() {
	output := flag.String("o", "", "output file path")
	flag.Parse()

	if *output == "" {
		fmt.Fprintf(os.Stderr, "Error: output file path is required\n")
		fmt.Fprintf(os.Stderr, "Usage: %s -o <output-file>\n", os.Args[0])
		os.Exit(1)
	}

	fd, err := os.Create(*output)
	if err != nil {
		panic(err)
	}
	defer fd.Close()

	// Collect DNS types
	var dnsTypes []DNSType
	for _, ty := range getSortedTypes() {
		typeName := dns.TypeToString[ty]
		// Remove hyphens from constant names (e.g., "NSAP-PTR" -> "TypeNSAPPTR")
		constantName := fmt.Sprintf("Type%s", strings.ReplaceAll(typeName, "-", ""))

		dnsTypes = append(dnsTypes, DNSType{
			Name:     typeName,
			Constant: constantName,
		})
	}

	// For reproducible builds, use SOURCE_DATE_EPOCH if set
	timestamp := time.Now()
	if epoch := os.Getenv("SOURCE_DATE_EPOCH"); epoch != "" {
		timestamp = time.Unix(0, 0)
	}

	tmpl := template.Must(template.New("dns_types").Parse(`// Code generated by go generate; DO NOT EDIT.
// This file was generated by tools/gen_dns_type_mapping.go
// Last generation: {{.Timestamp}}

package usecase

import (
	"reflect"

	"github.com/miekg/dns"
)

// getRRType maps a DNS record type to its corresponding RR type constant
func (ssu *serviceSpecsUsecase) getRRType(t reflect.Type) uint16 {
	// Get the type name (e.g., "A", "AAAA", "MX", etc.)
	typeName := t.Name()

	// Map type names to their RR type constants
	switch typeName {
{{- range .Types}}
	case "{{.Name}}":
		return dns.{{.Constant}}
{{- end}}
	default:
		return dns.TypeNone
	}
}
`))

	data := struct {
		Timestamp string
		Types     []DNSType
	}{
		Timestamp: timestamp.Format(time.UnixDate),
		Types:     dnsTypes,
	}

	if err := tmpl.Execute(fd, data); err != nil {
		panic(err)
	}

	fmt.Printf("Generated %s with %d DNS types\n", *output, len(dnsTypes))
}
