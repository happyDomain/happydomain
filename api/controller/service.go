// This file is part of the happyDomain (R) project.
// Copyright (c) 2020-2024 happyDomain
// Authors: Pierre-Olivier Mercier, et al.
//
// This program is offered under a commercial and under the AGPL license.
// For commercial licensing, contact us at <contact@happydomain.org>.
//
// For AGPL licensing:
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

package controller

import (
	"fmt"
	"log"
	"net/http"

	"github.com/gin-gonic/gin"

	"git.happydns.org/happyDomain/api/middleware"
	"git.happydns.org/happyDomain/model"
	"git.happydns.org/happyDomain/usecase"
)

type ServiceController struct {
	duService happydns.DomainUsecase
	suService happydns.ServiceUsecase
	zuService happydns.ZoneUsecase
}

func NewServiceController(duService happydns.DomainUsecase, suService happydns.ServiceUsecase, zuService happydns.ZoneUsecase) *ServiceController {
	return &ServiceController{
		duService: duService,
		suService: suService,
		zuService: zuService,
	}
}

// addZoneService adds a Service to the given subdomain of the Zone.
//
//	@Summary	Add a Service.
//	@Schemes
//	@Description	Add a Service to the given subdomain of the Zone.
//	@Tags			zones
//	@Accept			json
//	@Produce		json
//	@Security		securitydefinitions.basic
//	@Param			domainId	path		string	true	"Domain identifier"
//	@Param			zoneId		path		string	true	"Zone identifier"
//	@Param			subdomain	path		string	true	"Part of the subdomain considered for the service (@ for the root of the zone ; subdomain is relative to the root, do not include it)"
//	@Success		200			{object}	happydns.Zone
//	@Failure		400			{object}	happydns.ErrorResponse	"Invalid input"
//	@Failure		401			{object}	happydns.ErrorResponse	"Authentication failure"
//	@Failure		404			{object}	happydns.ErrorResponse	"Domain or Zone not found"
//	@Router			/domains/{domainId}/zone/{zoneId}/{subdomain}/services [post]
func (sc *ServiceController) AddZoneService(c *gin.Context) {
	user := middleware.MyUser(c)
	domain := c.MustGet("domain").(*happydns.Domain)
	zone := c.MustGet("zone").(*happydns.Zone)
	subdomain := c.MustGet("subdomain").(happydns.Subdomain)

	var usc happydns.ServiceMessage
	err := c.ShouldBindJSON(&usc)
	if err != nil {
		log.Printf("%s sends invalid service JSON: %s", c.ClientIP(), err.Error())
		c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"errmsg": fmt.Sprintf("Something is wrong in received data: %s", err.Error())})
		return
	}

	newservice, err := usecase.ParseService(&usc)
	if err != nil {
		middleware.ErrorResponse(c, http.StatusBadRequest, err)
		return
	}

	zone, err = sc.duService.AddServiceToZone(user, domain, zone, subdomain, happydns.Origin(domain.DomainName), newservice)
	if err != nil {
		middleware.ErrorResponse(c, http.StatusInternalServerError, err)
		return
	}

	c.JSON(http.StatusOK, zone)
}

// getServiceService retrieves the designated Service.
//
//	@Summary	Get the Service.
//	@Schemes
//	@Description	Retrieve the designated Service.
//	@Tags			zones
//	@Accept			json
//	@Produce		json
//	@Security		securitydefinitions.basic
//	@Param			domainId	path		string	true	"Domain identifier"
//	@Param			zoneId		path		string	true	"Zone identifier"
//	@Param			subdomain	path		string	true	"Part of the subdomain considered for the service (@ for the root of the zone ; subdomain is relative to the root, do not include it)"
//	@Param			serviceId	path		string	true	"Service identifier"
//	@Success		200			{object}	happydns.Service
//	@Failure		401			{object}	happydns.ErrorResponse	"Authentication failure"
//	@Failure		404			{object}	happydns.ErrorResponse	"Domain or Zone not found"
//	@Router			/domains/{domainId}/zone/{zoneId}/{subdomain}/services/{serviceId} [get]
func (sc *ServiceController) GetZoneService(c *gin.Context) {
	zone := c.MustGet("zone").(*happydns.Zone)
	serviceid := c.MustGet("serviceid").(happydns.Identifier)
	subdomain := c.MustGet("subdomain").(happydns.Subdomain)

	_, svc := zone.FindSubdomainService(subdomain, serviceid)

	c.JSON(http.StatusOK, svc)
}

// GetServiceRecords retrieves the records that will be generated by a Service.
//
//	@Summary	Get the records for a Service.
//	@Schemes
//	@Description	Retrieve the records that will be generated by a Service.
//	@Tags			zones
//	@Accept			json
//	@Produce		json
//	@Security		securitydefinitions.basic
//	@Param			domainId	path		string	true	"Domain identifier"
//	@Param			zoneId		path		string	true	"Zone identifier"
//	@Param			subdomain	path		string	true	"Part of the subdomain considered for the service (@ for the root of the zone ; subdomain is relative to the root, do not include it)"
//	@Param			serviceId	path		string	true	"Service identifier"
//	@Success		200			{object}	happydns.Zone
//	@Failure		401			{object}	happydns.ErrorResponse	"Authentication failure"
//	@Failure		404			{object}	happydns.ErrorResponse	"Domain or Zone not found"
//	@Router			/domains/{domainId}/zone/{zoneId}/{subdomain}/services/{serviceId}/records [get]
func (sc *ServiceController) GetServiceRecords(c *gin.Context) {
	domain := c.MustGet("domain").(*happydns.Domain)
	zone := c.MustGet("zone").(*happydns.Zone)
	serviceid := c.MustGet("serviceid").(happydns.Identifier)
	subdomain := c.MustGet("subdomain").(happydns.Subdomain)

	_, svc := zone.FindSubdomainService(subdomain, serviceid)
	if svc == nil {
		c.AbortWithStatusJSON(http.StatusNotFound, gin.H{"errmsg": "Service not found."})
		return
	}

	rrs, err := sc.suService.GetRecords(domain, zone, svc)
	if err != nil {
		middleware.ErrorResponse(c, http.StatusInternalServerError, err)
		return
	}

	ret := make([]*happydns.ServiceRecord, len(rrs))
	for i, rr := range rrs {
		ret[i] = happydns.RecordToServiceRecord(rr)
	}

	c.JSON(http.StatusOK, ret)
}

// UpdateZoneService adds or updates a service inside the given Zone.
//
//	@Summary	Add or update a Service.
//	@Schemes
//	@Description	Add or update a Service inside the given Zone.
//	@Tags			zones
//	@Accept			json
//	@Produce		json
//	@Security		securitydefinitions.basic
//	@Param			domainId	path		string						true	"Domain identifier"
//	@Param			zoneId		path		string						true	"Zone identifier"
//	@Param			body		body		happydns.Service	true	"Service to update"
//	@Success		200			{object}	happydns.Zone
//	@Failure		401			{object}	happydns.ErrorResponse	"Authentication failure"
//	@Failure		404			{object}	happydns.ErrorResponse	"Domain or Zone not found"
//	@Router			/domains/{domainId}/zone/{zoneId} [patch]
func (sc *ServiceController) UpdateZoneService(c *gin.Context) {
	user := middleware.MyUser(c)
	domain := c.MustGet("domain").(*happydns.Domain)
	zone := c.MustGet("zone").(*happydns.Zone)

	var usc happydns.ServiceMessage
	err := c.ShouldBindJSON(&usc)
	if err != nil {
		log.Printf("%s sends invalid domain JSON: %s", c.ClientIP(), err.Error())
		c.AbortWithStatusJSON(http.StatusBadRequest, gin.H{"errmsg": fmt.Sprintf("Something is wrong in received data: %s", err.Error())})
		return
	}

	newservice, err := usecase.ParseService(&usc)
	if err != nil {
		middleware.ErrorResponse(c, http.StatusBadRequest, err)
		return
	}

	zone, err = sc.duService.UpdateZoneService(user, domain, zone, happydns.Subdomain(usc.Domain), usc.Id, newservice)
	if err != nil {
		middleware.ErrorResponse(c, http.StatusInternalServerError, err)
		return
	}

	c.JSON(http.StatusOK, zone)
}

// deleteZoneService drops the given Service.
//
//	@Summary	Drop the given Service.
//	@Schemes
//	@Description	Drop the given Service.
//	@Tags			zones
//	@Accept			json
//	@Produce		json
//	@Security		securitydefinitions.basic
//	@Param			domainId	path		string	true	"Domain identifier"
//	@Param			zoneId		path		string	true	"Zone identifier"
//	@Param			subdomain	path		string	true	"Part of the subdomain considered for the service (@ for the root of the zone ; subdomain is relative to the root, do not include it)"
//	@Param			serviceId	path		string	true	"Service identifier"
//	@Success		200			{object}	happydns.Zone
//	@Failure		400			{object}	happydns.ErrorResponse	"Invalid input"
//	@Failure		401			{object}	happydns.ErrorResponse	"Authentication failure"
//	@Failure		404			{object}	happydns.ErrorResponse	"Domain or Zone not found"
//	@Router			/domains/{domainId}/zone/{zoneId}/{subdomain}/services/{serviceId} [delete]
func (sc *ServiceController) DeleteZoneService(c *gin.Context) {
	user := middleware.MyUser(c)
	domain := c.MustGet("domain").(*happydns.Domain)
	zone := c.MustGet("zone").(*happydns.Zone)
	serviceid := c.MustGet("serviceid").(happydns.Identifier)
	subdomain := c.MustGet("subdomain").(happydns.Subdomain)

	zone, err := sc.duService.RemoveServiceFromZone(user, domain, zone, subdomain, serviceid)
	if err != nil {
		middleware.ErrorResponse(c, http.StatusInternalServerError, err)
		return
	}

	c.JSON(http.StatusOK, zone)
}
